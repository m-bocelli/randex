package edu.udel.cisc675.randex;
import java.util.ArrayList;

/* Module FindAnswers: searches through the character array from the file,
   and for each problem, finds the starting and ending points of each answer.
   The answer includes "\item" and ends just before the next "\item" or
   "\end{enumerate}". */
public class FindAnswers {

    // strings we will search for...
    
    public final static char[] beginEnumerate =
	"\\begin{enumerate}".toCharArray();
    
    public final static char[] item = "\\item".toCharArray();
    
    public final static char[] endEnumerate =
	"\\end{enumerate}".toCharArray();

    /* The chars array generated by Input module (in) */
    FileStorage fileStorage;
	ProblemStorage problemStorage;
	AnswerStorage answerStorage;

    
    /* Constructs new FindAnswers instance from the given data.  Sets
       the fields and does nothing else. */
    public FindAnswers(FileStorage fileStorage, ProblemStorage problemStorage, AnswerStorage answerStorage) {
		this.fileStorage = fileStorage;
		this.problemStorage = problemStorage;
		this.answerStorage = answerStorage;
    }

    /* Tells you whether the sequence of chars starting at position in
       array chars matches those of c */
    private boolean match(int off, char[] c) {
		int n = c.length;
		if (off+n > fileStorage.getChars().length)
			return false;
		for (int i=0; i<n; i++) {
			if (c[i] != fileStorage.getChar(off+i))
				return false;
		}
		return true;
    }

    /* Finds the answers to the problem with ID pid, setting
       answerStarts[pid] and answerStops[pid].  */
    private void findAnswersInProblem(int pid) {
		ArrayList<Integer> startList = new ArrayList<>(),
			stopList = new ArrayList<>();
		int i = problemStorage.getProblemStartsI(pid); // starting character index for problem pid
		int stop = problemStorage.getProblemStopsI(pid);
		for (; i < stop && !match(i, answerStorage.beginEnumerate); i++) ;
		if (i == stop)
			throw new RuntimeException("No \\begin{enumerate} found for problem "+pid);
		for (; i < stop; i++) {
			if (match(i, answerStorage.endEnumerate)) {
				if (!startList.isEmpty()) stopList.add(i);
					break;
			}
			if (match(i, answerStorage.item)) {
				if (!startList.isEmpty()) stopList.add(i);
				startList.add(i);
			}
		}
		if (i == stop)
			throw new RuntimeException("No \\end{enumerate} found for problem "+pid);
		int nanswer = startList.size();
		assert nanswer == stopList.size();
		answerStorage.setAnswers(startList, stopList, pid);
    }

    /* Constructs answerStarts and answerStops. */
    public void execute() {
		int nprob = problemStorage.getProblemStarts.length;
		answerStorage.initAnswers(nprob);
		for (int i=0; i<nprob; i++)
			findAnswersInProblem(i);
    }
}
